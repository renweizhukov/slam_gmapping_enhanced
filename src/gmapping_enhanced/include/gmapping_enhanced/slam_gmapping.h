/*
 * Copyright (c) 2008, Willow Garage, Inc.
 *
 * THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE
 * COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS PROTECTED BY
 * COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS
 * AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
 * 
 * BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO
 * BE BOUND BY THE TERMS OF THIS LICENSE. THE LICENSOR GRANTS YOU THE RIGHTS
 * CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND
 * CONDITIONS.
 *
 */

/*
 * Copyright (c) 2017, Beijing SmartConn Tech. Co.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Author: Brian Gerkey */
/* Modified by: Wei Ren */

// ROS headers
#include <ros/ros.h>
#include <sensor_msgs/LaserScan.h>
#include <std_msgs/Float64.h>
#include <nav_msgs/GetMap.h>
#include <tf/transform_listener.h>
#include <tf/transform_broadcaster.h>
#include <message_filters/subscriber.h>
#include <tf/message_filter.h>

// openslam_gmapping headers
#include "gmapping/gridfastslam/gridslamprocessor.h"

// std header
#include <string>
#include <vector>
#include <memory>
#include <thread>
#include <mutex>

class SlamGMapping
{
private:
    /////////////////////////////////////////////////////////////////////
    // ROS-related member variables                                    //
    /////////////////////////////////////////////////////////////////////

    // Two ROS node handles: 
    // (1) Publish/subscribe non-private topics and handles a non-private service.
    ros::NodeHandle m_nodeHandle;
    // (2) Retrieve private parameters and publishes a private topic.
    ros::NodeHandle m_privateNodeHandle;

    // Subscriber for the laser scan:
    // (1) A simple wrapper around a ROS subscriber that provides a source for the TF 
    // MessageFilter. It subscribes to the topic "scan" with the data type "sensor_msgs/LaserScan".
    std::unique_ptr<message_filters::Subscriber<sensor_msgs::LaserScan>> m_laserScanSubscriber;
    // (2) A helper which caches the laser scan data until it is possible to transform the 
    // laser scan frame into the odometry frame. 
    std::unique_ptr<tf::MessageFilter<sensor_msgs::LaserScan>> m_laserScanTfFilter;

    // Publishers:
    // (1) Publish the meta data of the grid map periodically. It publishes topic "map_metadata"
    //     with the data type "nav_msgs/MapMetaData".
    ros::Publisher m_mapMetaDataPublisher;
    // (2) Publish the grid map periodically. It publishes the topic "map" with the data type 
    //     "nav_msgs/OccupancyGrid".
    ros::Publisher m_mapPublisher;
    // (3) Publishes the entropy of the distribution over the robot's pose where a higher value 
    //     indicates greater uncertainty. It publishes the private topic "~entropy" with the data  
    //     type "std_msgs/Float64".
    ros::Publisher m_privateEntropyPublisher;

    // Service:
    // m_getMapService is called to get the latest grid map. The service name is "dynamic_map", the 
    // service type is "nav_msgs/GetMap", and the data type of the response is "nav_msgs/OccupancyGrid".
    ros::ServiceServer m_getMapService;
    // The service response which stores the latest map generated by GMapping.
    nav_msgs::GetMap::Response m_map;

    // Parameters:
    // (1) Parameters used by this wrapper class:
    // Process 1 out of every this many scans (set it to a higher number to skip more scans). 
    int m_throttleScans;
    // The tf frame attached to the robot base pose
    std::string m_baseFrame;
    // The tf frame where the robot pose on the map is published 
    std::string m_mapFrame;
    // The tf frame from which odometry is read
    std::string m_odomFrame;
    // Time in seconds between two consecutive calculations of the map grids
    ros::Duration m_mapUpdateInterval;
    // Time in seconds between two consecutive TF transform publications
    double m_tfTransformPublishPeriod;
    // This time delay (default: m_tfTransformPublishPeriod) is added to the current time and the sum 
    // will be set as the time stamp of the TF transform. 
    double m_tfDelay;
    // The threshold on openslam_gmapping occupancy values above which the cell is considered occupied 
    // (set to 100 in the grid map).
    double m_mapOccupancyThreshold;

    // (2) Parameters used by the openslam_gmapping library:
    //
    // LiDAR parameters:
    //
    // The maximum range of the laser scans. Rays beyond this range get discarded completely 
    // (default: maximum laser range minus 1 cm, as received in the the first LaserScan message)
    double m_maxRange;
    // The maximum range of the laser scanner that is used for map building (default: same as m_maxRange)
    double m_maxURange;
    //
    // Laser-scan-matching parameters:
    // 
    // The standard deviation for the scan matching process (cell)
    double m_sigma;
    // The search window for the scan matching process
    int m_kernelSize;
    // The initial linear search step for scan matching in translation
    double m_lstep;
    // The initial angular search step for scan matching in rotation
    double m_astep;
    // The number of refinement steps in the scan matching. 
    // The final "precision" for the match is lstep*2^(-iterations) or astep*2^(-iterations), respectively.
    int m_iterations;
    // The standard deviation of a single laser beam for the scan matching process
    double m_lsigma;
    // The gain for smoothing the likelihood
    double m_ogain;
    // Take only every (n+1)th laser ray for computing a match (0 = take all rays).
    int m_lskip;
    // The minimum score for considering the outcome of the scanmatching good. 
    // Can avoid 'jumping' pose estimates in large open spaces when using laser scanners with limited range (e.g. 5m)
    // (0 = default. Scores go up to 600+, try 50 for example when experiencing 'jumping' estimate issues).
    double m_minimumScore;
    // The following four parameters are for likelihood sampling used in scan matching.
    // The linear (i.e., translational) range
    double m_llSampleRange;
    // The linear (i.e., translational) step
    double m_llSampleStep;
    // The angular (i.e., rotational) range
    double m_laSampleRange;
    // The angular (i.e., rotational) step
    double m_laSampleStep;
    //
    // Motion model parameters:
    // 
    // All four parameters are standard deviations of a gaussian noise model.
    // The linear noise component (x and y)
    double m_srr;
    // The angular noise component (theta)
    double m_srt;
    // The linear -> angular noise component 
    double m_str;
    // The angular -> linear noise component
    double m_stt;
    //
    // Rao-Blackwellized particle filter parameters:
    // 
    // The robot only processes new scans if the robot has moved at least this many meters.
    double m_linearUpdate;
    // The robot only processes new scans if the robot has turned at least this many radians.
    double m_angularUpdate;
    // The robot only processes new scans if the last scan processed is older than the update 
    // time in seconds. A negative value will turn of time-based updates. 
    double m_temporalUpdate;
    // The Neff threshold below which the particles get resampled. A higher value implies 
    // more frequent resampling.
    double m_resampleThreshold;
    // A fixed number of particles. Each particle represents a possible robot trajectory.
    int m_cntParticles;
    //
    // Map parameters;
    //
    // The minimum x position in the initial map
    double m_initMapXMin;
    // The minimum y position in the initial map
    double m_initMapYMin;
    // The maximum x position in the initial map
    double m_initMapXMax;
    // The maximum y position in the initial map
    double m_initMapYMax;
    // The map resolution
    double m_mapResolution;
    
    // TF transforms:
    // (1) Required TF transforms:
    // A valid TF transform from laser_scan to odom is required, which is usually generated 
    // by concatenating the following two TF transfroms:
    // laser_scan -> base_link: usually a fixed value, broadcast periodically by a robot_state_publisher, 
    //                          or a TF static_transform_publisher
    // base_link -> odom: provided by the odometry system (i.e., the driver for the mobile base)
    tf::TransformListener m_tfListener;
    
    // (2) Provided TF transforms:
    tf::TransformBroadcaster m_tfBroadcaster;
    // The TF transform from map to odom which will be broadcasted
    tf::Transform m_mapToOdomTf;

    /////////////////////////////////////////////////////////////////////
    // Internal member variables                                       //
    /////////////////////////////////////////////////////////////////////

    //
    // GMapping class instances and parameters:
    // 
    std::unique_ptr<GMapping::GridSlamProcessor> m_gsp;
    std::unique_ptr<GMapping::RangeSensor> m_gspLaser;
    unsigned long int m_samplingSeed;

    //
    // LiDAR parameters:
    //
    // Frame ID of the laser scan
    std::string m_laserFrame;
    // Number of the laser scans that have been received so far
    unsigned int m_cntLaserScans;
    // Number of the laser beams in one scan
    unsigned int m_cntLaserBeams;
    // Depending on the order of the elements in the scan and the orientation of the scan frame 
    // (i.e., the z-axis of the scan frame is pointing upwards/downwards), we might need to 
    // reverse the order of the scan.
    bool m_doReverseRange;
    // The pose, in the original laser frame, of the corresponding centered laser with z facing up
    tf::Stamped<tf::Pose> m_centeredLaserPose;
    // The beam angles in the laser scan, going from -x to x and then back to -x (adjustment is made 
    // to get the laser between symmetrical bounds as that's what gmapping expects)
    std::vector<double> m_laserBeamAngles;
    // This flag indicates whether we have got the first laser scan.
    bool m_gotFirstLaserScan;

    //
    // Other parameters:
    //
    // This flag indicates whether we have got a map generated by GMapping.
    bool m_gotMap;
    // The last time when the map was updated
    ros::Time m_lastMapUpdateTime;
    // The mutex which protects the map-to-odom TF transform
    std::mutex m_mapToOdomMutex; 
    // The mutex which protects the grid map
    std::mutex m_mapMutex;
    // The thread which will be used for publishing the map-to-odom TF transform
    std::unique_ptr<std::thread> m_tfTransformPublishThread;

    /////////////////////////////////////////////////////////////////////
    // Internal member functions                                       //
    /////////////////////////////////////////////////////////////////////
    // Create GMapping objects and initialize the private parameters.
    void Init();
    // Initialize GMapping when we receive the first laser scan.
    bool InitGMapping(const sensor_msgs::LaserScan& scan);
    // Get the centered laser beam pose in the odom frame.
    bool GetCenteredLaserPoseInOdom(GMapping::OrientedPoint& odomPose, const ros::Time& t);
    // The callback which handles the subscribed laser scan message
    void LaserCallback(const sensor_msgs::LaserScan::ConstPtr& scan);
    // Pre-process the laser scan and then pass it to GMapping.
    bool AddScan(const sensor_msgs::LaserScan& scan, GMapping::OrientedPoint& odomPose);
    // The callback which handles the dynamic_map service call
    bool MapCallback(nav_msgs::GetMap::Request& request, nav_msgs::GetMap::Response& response);
    // Update the grid map periodically based on the laser scans.
    void UpdateMap(const sensor_msgs::LaserScan& scan);
    // Compute the entropy of the distribution over the robot's pose where a higher value indicates 
    // greater uncertainty.
    double ComputePoseEntropy();
    // The infinite loop which invokes PublishTfTransform to publish the map-to-odom TF transform
    void PublishTfTransformLoop(double tfTransformPublishPeriod);
    void PublishTfTransform();

public:
    SlamGMapping();
    SlamGMapping(ros::NodeHandle& nh, ros::NodeHandle& pnh);
    SlamGMapping(unsigned long int seed, unsigned long int maxDurationBuffer);
    ~SlamGMapping();

    // Start a live SLAM session.
    void StartLiveSlam();
    // Start a replay SLAM session where the laser scan data and the TF transforms are from 
    // a bag file.
    void StartReplay(const std::string& bagFileName, const std::string& scanTopic);
};
